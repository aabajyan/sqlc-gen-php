<?php
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

declare(strict_types=1);

namespace App\Sqlc\SQLite;

const bookByTags = "-- name: bookByTags :many
SELECT
    book_id,
    title,
    name,
    isbn,
    tags
FROM
    book
    LEFT JOIN author ON book.author_id = author.author_id
WHERE
    tags = ?
";

const bookByTagsMultiple = "-- name: bookByTagsMultiple :many
SELECT
    book_id,
    title,
    name,
    isbn,
    tags
FROM
    book
    LEFT JOIN author ON book.author_id = author.author_id
WHERE
    tags IN (/*SLICE:tags*/?)
";

const bookByTitleYear = "-- name: bookByTitleYear :many
SELECT
    book_id, author_id, isbn, book_type, title, yr, available, tags
FROM
    book
WHERE
    title = UUID_TO_BIN(?)
    AND yr = ?
";

const createAuthor = "-- name: createAuthor :execresult
INSERT INTO
    author (name)
VALUES
    (?)
";

const createBook = "-- name: createBook :execresult
INSERT INTO
    book (
        author_id,
        isbn,
        book_type,
        title,
        yr,
        available,
        tags
    )
VALUES
    (
        ?,
        ?,
        ?,
        UUID_TO_BIN(?),
        ?,
        ?,
        ?
    )
";

const deleteAuthorBeforeYear = "-- name: deleteAuthorBeforeYear :exec
DELETE FROM
    book
WHERE
    yr < ?
    AND author_id = ?
";

const deleteBook = "-- name: deleteBook :exec
DELETE FROM
    book
WHERE
    book_id = ?
";

const getAuthor = "-- name: getAuthor :one
SELECT
    author_id, name
FROM
    author
WHERE
    author_id = ?
";

const getBook = "-- name: getBook :one
SELECT
    book_id, author_id, isbn, book_type, title, yr, available, tags
FROM
    book
WHERE
    book_id = ?
";

const listAuthors = "-- name: listAuthors :many
SELECT
    author_id, name
FROM
    author
ORDER BY
    name
";

const updateBook = "-- name: updateBook :exec
UPDATE
    book
SET
    title = ?,
    tags = ?
WHERE
    book_id = ?
";

const updateBookISBN = "-- name: updateBookISBN :exec
UPDATE
    book
SET
    title = ?,
    tags = ?,
    isbn = ?
WHERE
    book_id = ?
";

final readonly class QueriesImpl implements Queries {
    public function __construct(private \PDO $pdo) {}

    /**
     * @return BookByTagsRow[]
     * @throws \Exception
     */
    public function bookByTags(string $tags): array
    {
        $stmt = $this->pdo->prepare(bookByTags);
        $stmt->execute([$tags]);
        $results = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        /**
         * @var BookByTagsRow[]
         */
        $ret = [];
        foreach ($results as $row) {
            $ret[] = new BookByTagsRow(    $row["book_id"],
    $row["title"],
    $row["name"],
    $row["isbn"],
    $row["tags"]);
        }
        return $ret;
    }

    /**
     * @return BookByTagsMultipleRow[]
     * @throws \Exception
     */
    public function bookByTagsMultiple(array $tags): array
    {
        $stmt = $this->pdo->prepare(bookByTagsMultiple);
        $stmt->execute([$tags]);
        $results = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        /**
         * @var BookByTagsMultipleRow[]
         */
        $ret = [];
        foreach ($results as $row) {
            $ret[] = new BookByTagsMultipleRow(    $row["book_id"],
    $row["title"],
    $row["name"],
    $row["isbn"],
    $row["tags"]);
        }
        return $ret;
    }

    /**
     * @return Book[]
     * @throws \Exception
     */
    public function bookByTitleYear(mixed $uuidToBin, int $yr): array
    {
        $stmt = $this->pdo->prepare(bookByTitleYear);
        $stmt->execute([$uuidToBin,
          $yr]);
        $results = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        /**
         * @var Book[]
         */
        $ret = [];
        foreach ($results as $row) {
            $ret[] = new Book(    $row["book_id"],
    $row["author_id"],
    $row["isbn"],
    $row["book_type"],
    $row["title"],
    $row["yr"],
    $row["available"] == null ? null : new \DateTimeImmutable($row["available"]),
    $row["tags"]);
        }
        return $ret;
    }

    /**
     * @throws \Exception
     */
    public function createAuthor(string $name): int|string {
        $stmt = $this->pdo->prepare(createAuthor);
        $stmt->execute([$name]);
        return $this->pdo->lastInsertId();
    }

    /**
     * @throws \Exception
     */
    public function createBook(
      int $authorId,
      string $isbn,
      string $bookType,
      mixed $uuidToBin,
      int $yr,
      \DateTimeImmutable $available,
      string $tags): int|string {
        $stmt = $this->pdo->prepare(createBook);
        $stmt->execute([$authorId,
          $isbn,
          $bookType,
          $uuidToBin,
          $yr,
          $available,
          $tags]);
        return $this->pdo->lastInsertId();
    }

    /**
     * @throws \Exception
     */
    public function deleteAuthorBeforeYear(int $yr, int $authorId): void
    {
        $stmt = $this->pdo->prepare(deleteAuthorBeforeYear);
        $stmt->execute([$yr,
          $authorId]);
    }

    /**
     * @throws \Exception
     */
    public function deleteBook(int $bookId): void
    {
        $stmt = $this->pdo->prepare(deleteBook);
        $stmt->execute([$bookId]);
    }

    /**
     * @return Author|null
     * @throws \Exception
     */
    public function getAuthor(int $authorId): ?Author
    {
        $stmt = $this->pdo->prepare(getAuthor);
        $stmt->execute([$authorId]);
        $results = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        /**
         * @var Author[]
         */
        $ret = [];
        if(count($results) != 1){
            throw new \Exception("NOT 1 ROW RETURNED");
        }
        foreach ($results as $row) {
            $ret[] = new Author(    $row["author_id"],
    $row["name"]);
        }
        return $ret[0];
    }

    /**
     * @return Book|null
     * @throws \Exception
     */
    public function getBook(int $bookId): ?Book
    {
        $stmt = $this->pdo->prepare(getBook);
        $stmt->execute([$bookId]);
        $results = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        /**
         * @var Book[]
         */
        $ret = [];
        if(count($results) != 1){
            throw new \Exception("NOT 1 ROW RETURNED");
        }
        foreach ($results as $row) {
            $ret[] = new Book(    $row["book_id"],
    $row["author_id"],
    $row["isbn"],
    $row["book_type"],
    $row["title"],
    $row["yr"],
    $row["available"] == null ? null : new \DateTimeImmutable($row["available"]),
    $row["tags"]);
        }
        return $ret[0];
    }

    /**
     * @return Author[]
     * @throws \Exception
     */
    public function listAuthors(): array
    {
        $stmt = $this->pdo->prepare(listAuthors);
        $stmt->execute([]);
        $results = $stmt->fetchAll(\PDO::FETCH_ASSOC);
        /**
         * @var Author[]
         */
        $ret = [];
        foreach ($results as $row) {
            $ret[] = new Author(    $row["author_id"],
    $row["name"]);
        }
        return $ret;
    }

    /**
     * @throws \Exception
     */
    public function updateBook(
      string $title,
      string $tags,
      int $bookId): void
    {
        $stmt = $this->pdo->prepare(updateBook);
        $stmt->execute([$title,
          $tags,
          $bookId]);
    }

    /**
     * @throws \Exception
     */
    public function updateBookISBN(
      string $title,
      string $tags,
      string $isbn,
      int $bookId): void
    {
        $stmt = $this->pdo->prepare(updateBookISBN);
        $stmt->execute([$title,
          $tags,
          $isbn,
          $bookId]);
    }

}

